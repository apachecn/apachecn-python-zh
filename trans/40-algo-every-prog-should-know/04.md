# 设计算法

本章介绍各种算法的核心设计概念。它讨论了设计算法的各种技术的优缺点。通过理解这些概念，您将学习如何设计高效的算法。

本章首先讨论设计算法时可供选择的不同选项。然后，它讨论了描述我们试图解决的特定问题的重要性。接下来，它使用著名的**旅行商问题**（**TSP**作为一个用例，并应用我们将要介绍的不同设计技术。然后，介绍了线性规划并讨论了它的应用。最后，介绍了如何使用线性规划来解决实际问题。

在本章结束时，您应该能够理解设计高效算法的基本概念。

本章讨论了以下概念：

*   设计算法的各种方法
*   了解为算法选择正确设计所涉及的权衡
*   制定真实世界问题的最佳实践
*   解决实际优化问题

让我们首先看一下设计算法的基本概念。

# 介绍设计算法的基本概念

根据美国传统词典，算法定义如下：

"A finite set of unambiguous instructions that given some set of initial conditions can be performed in a prescribed sequence to achieve a certain goal and that has a recognizable set of end conditions."

设计一个算法就是以最有效的方式提出这个“*有限的无歧义指令集*”，以“*实现某个目标*”。对于一个复杂的现实世界问题，设计一个算法是一项繁琐的任务。要想出一个好的设计，我们首先需要充分理解我们试图解决的问题。我们先弄清楚*需要做什么*（即理解需求），然后再研究*如何做*（即设计算法）。理解问题包括解决问题的功能性和非功能性需求。让我们看看这些是什么：

*   功能需求正式指定了我们想要解决的问题的输入和输出接口以及与之相关的功能。功能需求帮助我们理解数据处理、数据操作以及生成结果所需的计算。
*   非功能性需求设定了对算法性能和安全方面的期望。

请注意，设计算法是指在给定的一组环境下，以尽可能最佳的方式解决功能性和非功能性需求，并记住可用于运行所设计算法的资源集。

如[第 1 章](04.html)、*算法概述*所述，为了得到能够满足功能性和非功能性需求的良好响应，我们的设计应考虑以下三个方面：

*   问题 1：设计的算法会产生我们期望的结果吗？
*   问题 2：这是获得这些结果的最佳方式吗？
*   问题 3：该算法将如何在较大的数据集上执行？

在本节中，让我们逐一了解这些关注点。

# 问题 1–设计的算法是否会产生我们预期的结果？

算法是对现实世界问题的数学解决方案。为了有用，它应该产生准确的结果。如何验证算法的正确性不应是事后诸葛亮；相反，它应该融入算法的设计中。在制定验证算法的策略之前，我们需要考虑以下两个方面：

*   **定义真值**：为了验证算法，我们需要一些已知的、针对给定输入集的正确结果。在我们试图解决的问题的背景下，这些已知的正确结果被称为**真理**。**真理**很重要，因为当我们迭代地努力进化算法以获得更好的解决方案时，它被用作参考。
*   **选择指标**：我们还需要考虑如何量化与定义真理的偏差。选择正确的度量将帮助我们准确地量化算法的质量。

例如，对于机器学习算法，我们可以使用现有的标记数据作为真理。我们可以选择一个或多个指标，如准确性、召回率或精确度，来量化与事实的偏差。需要注意的是，在某些用例中，正确的输出不是单个值。相反，正确的输出定义为给定输入集的范围。当我们致力于算法的设计和开发时，目标将是迭代地改进算法，直到它在需求中指定的范围内。

# 问题 2–这是获得这些结果的最佳方式吗？

第二个问题是找到以下问题的答案：

<q>Is this the optimal solution and can we verify that no other solution exists for this problem that is better than our solution?</q>

乍一看，这个问题很容易回答。然而，对于某一类算法，研究人员花了几十年的时间来验证由算法生成的特定解是否也是最好的，以及是否存在其他能给出更好结果的解，但都没有成功。因此，我们首先了解问题、需求以及运行算法所需的资源就变得非常重要。我们需要确认以下声明：

<q>Should we aim to find the optimal solution for this problem? Finding and verifying the optimal solution is so time-consuming and complex that a workable solution based on heuristics is our best bet.</q>

因此，了解问题及其复杂性非常重要，有助于我们估计所需资源。

在我们开始深入研究之前，首先，让我们在这里定义几个术语：

*   **多项式算法：**如果算法的时间复杂度为*O（n**<sup>k</sup>**，我们称之为多项式算法，其中*k*为常数。*
**   **证书：**迭代结束时产生的建议候选解决方案称为**证书**。当我们迭代地解决一个特定问题时，我们通常会生成一系列证书。如果解决方案正在向收敛方向发展，则生成的每个证书都将比前一个证书更好。在某种程度上，当我们的证书满足要求时，我们将选择该证书作为最终解决方案。*

 *在[第一章](04.html)*算法概述*中，我们引入了大 O 符号，可以用来分析算法的时间复杂度。在分析时间复杂性的背景下，我们将研究以下不同的时间间隔：

*   算法生成建议解决方案所需的时间，称为证书（*t<sub>r</sub>*）
*   验证建议解决方案（证书）所需的时间，*t<sub>s</sub>*

# 描述问题的复杂性

多年来，研究界根据问题的复杂性将其分为不同的类别。在我们试图设计一个问题的解决方案之前，首先尝试描述它是有意义的。一般来说，有三类问题：

*   类型 1：我们可以保证存在多项式算法来解决的问题
*   类型 2：我们可以证明多项式算法无法解决的问题
*   类型 3：我们无法找到多项式算法来解决的问题，但我们也无法证明这些问题的多项式解是不可能找到的

让我们看看各种类型的问题：

*   **非确定性多项式**（**NP**）：一个问题要成为 NP 问题，必须满足以下条件：
    *   可以保证有一个多项式算法可用于验证候选解决方案（证书）是最优的。
*   **多项式**（**P**）：这些类型的问题可以被认为是 NP 的子集。除了满足 NP 问题的条件外，P 问题还需要满足另一个条件：
    *   可以保证至少有一个多项式算法可用于解决这些问题。

**P**与**NP**问题的关系如下图所示：

![](assets/efff141e-c598-4dfc-9b52-650de9d52230.png)

If a problem is NP, is it P as well? This is one of the greatest problems in computer science that remains unresolved. Millennium Prize Problems, selected by the Clay Mathematics Institute, has announced a 1 million dollar prize for the solution to this problem as it will have a major impact on fields such as AI, cryptography, and theoretical computer sciences:
![](assets/99b84b3d-f132-4aad-b80d-084d61c79810.png)

让我们继续列出各种类型的问题：

*   **NP 完全**：NP 完全范畴包含所有 NP 问题中最难的问题。NP 完全问题满足以下两个条件：
    *   没有已知的多项式算法来生成证书。
    *   有已知的多项式算法来验证所提出的证书是最优的。
*   **NP 难**：NP 难类别包含的问题至少与 NP 类别中的任何问题一样难，但它们本身不需要属于 NP 类别。

现在，让我们尝试绘制一个图表来说明这些不同类型的问题：

![](assets/7f1eae28-466f-4476-b8bf-d8e6389b0f62.png)

请注意，研究界仍需证明 P=NP。尽管这一点尚未得到证实，但极有可能 P≠ NP 在这种情况下，NP 完全问题不存在多项式解。请注意，前面的图表基于此假设。

# 问题 3–算法将如何在较大的数据集上执行？

算法以定义的方式处理数据以产生结果。通常，随着数据量的增加，处理数据和计算所需结果所需的时间也越来越多。术语*大数据*有时用于粗略识别由于其容量、多样性和速度而对基础设施和算法具有挑战性的数据集。一个设计良好的算法应该是可伸缩的，这意味着它应该以一种方式设计，即在可能的情况下，它应该能够高效运行，利用可用资源，并在合理的时间范围内生成正确的结果。在处理大数据时，算法的设计变得更加重要。要量化算法的可伸缩性，我们需要记住以下两个方面：

*   **随着输入数据的增加而增加的资源需求**：估计这样的需求称为空间复杂性分析。
*   **随着输入数据的增加，运行所需时间的增加**：这一估计称为时间复杂性分析。

请注意，我们生活在一个由数据爆炸定义的时代。术语*大数据*已经成为主流，因为它捕获了现代算法通常需要处理的数据的大小和复杂性。

在开发和测试阶段，许多算法只使用一小部分数据。在设计算法时，研究算法的可伸缩性是很重要的。特别是，随着数据集规模的增加，仔细分析（即测试或预测）算法性能的影响非常重要。

# 理解算法策略

一个设计良好的算法试图通过尽可能将问题划分为更小的子问题来最有效地利用可用资源。设计算法有不同的算法策略。算法策略处理包含缺失算法方面的算法列表的以下三个方面。

在本节中，我们将介绍以下三种策略：

*   分而治之战略
*   动态规划策略
*   贪婪算法策略

# 理解分而治之战略

其中一个策略是找到一种方法，将一个较大的问题划分为可独立解决的较小问题。然后将这些子问题产生的子解组合起来，生成问题的整体解。这就是所谓的**分而治之**战略。

从数学上讲，如果我们正在设计一个问题的解决方案（*P*），该问题的*n*输入需要处理数据集*d*，我们将该问题分解为*k*子问题、*P<sub>1</sub>到*P<sub>k</sub>*。每个子问题将处理数据集的一个分区*d*。通常，我们会有*P**<sub>1</sub>*到*P**<sub>k</sub>*处理*d<sub>1</sub>到*d【T35 k*。**

让我们看一个实际的例子。

# 实用示例–分而治之应用于 Apache Spark

ApacheSpark 是一个开源框架，用于解决复杂的分布式问题。它采用分而治之的策略来解决问题。为了处理一个问题，它将问题划分为不同的子问题，并相互独立地处理它们。我们将使用一个简单的例子来演示这一点，从列表中计算单词。

假设我们有以下单词列表：

`wordsList = [python, java, ottawa, news, java, ottawa]`

我们要计算这个列表中每个单词的频率。为此，我们将采用分而治之的策略以有效的方式解决这个问题。

分治的实现如下图所示：

![](assets/0803c96a-de47-4fda-aa52-9f6ad7e7d81a.png)

上图显示了问题分为以下几个阶段：

1.  **拆分**：将输入数据划分为可独立处理的分区。这叫做分裂。上图中我们有三个*分割*。
2.  **映射**：任何可以在拆分上独立运行的操作都称为映射。在上图中，映射操作将分区中的每个字转换为键值对。与三个拆分相对应，有三个并行运行的映射器。
3.  **洗牌**：洗牌是将相似的按键组合在一起的过程。一旦将相似的键组合在一起，就可以对它们的值运行聚合函数。请注意，*洗牌*是一项性能密集型操作，因为需要将最初可以在网络上分发的类似密钥组合在一起。
4.  **减少**：对相似键的值运行聚合函数称为减少。在上图中，我们必须计算字数。

让我们看看如何编写代码来实现这一点。为了演示分治策略，我们需要一个分布式计算框架。为此，我们将在 Apache Spark 上运行 Python：

1.  首先，为了使用 Apache Spark，我们将创建 Apache Spark 的运行时上下文：

```py
import findspark
findspark.init()
from pyspark.sql import SparkSession
spark = SparkSession.builder.master("local[*]").getOrCreate()
sc = spark.sparkContext
```

2.  现在，让我们创建一个包含一些单词的示例列表。我们将此列表转换为 Spark 的本地分布式数据结构，称为**弹性分布式数据集**（**RDD**）：

```py
wordsList = ['python', 'java', 'ottawa', 'ottawa', 'java','news']
wordsRDD = sc.parallelize(wordsList, 4)
# Print out the type of wordsRDD
print (wordsRDD.collect())
```

3.  现在，让我们使用`map`函数将单词转换为键值对：

![](assets/b3cc81ba-f3bf-4ed1-8032-c0ff42b7bd35.png)

4.  让我们使用`reduce`函数进行聚合，得到最终结果：

![](assets/a2340460-95d3-45ef-818e-095913d82680.png)

这说明了我们如何使用分而治之的策略来计算字数。

Modern cloud computing infrastructures, such as Microsoft Azure, Amazon Web Services, and Google Cloud, achieve scalability by implementing a divide-and-conquer strategy either directly or indirectly behind the scenes.

# 理解动态规划策略

动态规划是 Richard Bellman 在 20 世纪 50 年代提出的一种策略，用于优化某些类别的算法。它基于一种智能缓存机制，试图重用繁重的计算。这种智能缓存机制称为**记忆**。

当我们试图解决的问题可以划分为子问题时，动态规划提供了良好的性能优势。子问题部分涉及在这些子问题中重复的计算。其思想是执行一次计算（这是一个耗时的步骤），然后在其他子问题上重用它。这是通过记忆来实现的，这在解决可能多次计算相同输入的递归问题时特别有用。

# 理解贪婪算法

在深入本节之前，让我们先定义两个术语：

*   **算法开销**：每当我们试图找到某个问题的最优解决方案时，都需要一些时间。随着我们试图优化的问题变得越来越复杂，找到最优解所需的时间也在增加。我们用*Ω<sub>i</sub>*表示算法开销。
*   **最优增量**：对于给定的优化问题，存在一个最优解。通常，我们使用我们选择的算法迭代优化解决方案。对于给定的问题，总是存在一个完美的解决方案，称为当前问题的**最优解**。如前所述，根据我们试图解决的问题的分类，最优解可能是未知的，或者需要花费不合理的时间来计算和验证。假设最优解已知，在*i**<sup>第</sup>*次迭代中，当前解与最优解的差异称为**与最优解的差值**，用*Δ**i<sub>i</sub>*表示。

对于复杂问题，我们有两种可能的策略：

*   **策略 1:**花更多时间寻找最接近最优的解决方案，使*Δ*<sub>*i*</sub>尽可能小。
*   **策略 2:**最小化算法开销，*Ω*<sub>*i*</sub>。使用快速和肮脏的方法，只是使用一个可行的解决方案。

贪婪算法基于策略 2，在策略 2 中，我们不努力寻找全局最优解，而是选择最小化算法开销。

对于多阶段问题，使用贪婪算法是一种快速而简单的寻找全局最优值的策略。它基于选择局部最优值，而不需要验证局部最优值是否也是全局最优值。通常，除非我们运气好，否则贪婪算法不会产生一个可以被认为是全局最优的值。然而，寻找全局最优值是一项耗时的任务。因此，与分治和动态规划算法相比，贪婪算法速度更快。

通常，贪婪算法定义如下：

1.  假设我们有一个数据集，*D*。在该数据集中，选择一个元素*k*。
2.  假设候选解决方案或证书为*s*。在溶液中考虑包括 Ty2 T2。如果可以包含，则解决方案为*联合体（S，e）*。
3.  重复此过程，直到*S*加满或*D*用尽。

# 实际应用–解决 TSP 问题

让我们首先看看 TSP 的问题陈述，这是一个众所周知的问题，在 20 世纪 30 年代被认为是一个挑战。TSP 问题是一个 NP 难问题。首先，我们可以随机生成满足访问所有城市条件的旅游，而不考虑最优解决方案。然后，我们可以在每次迭代中改进解决方案。迭代中生成的每个巡更称为候选解决方案（也称为证书）。证明证书是最优的需要的时间呈指数增长。相反，使用不同的基于启发式的解决方案生成接近最优但不是最优的旅行。

旅行推销员需要访问给定的城市列表才能完成工作：

| 输入 | *n*城市列表（表示为*V*以及每对城市之间的距离，*d ij（1）≤ i、 j≤ n）* |
| 输出 | 访问每个城市一次并返回初始城市的最短行程 |

注意以下几点：

*   名单上的城市之间的距离是已知的，
*   给定列表中的每个城市需要访问*一次。*

我们可以为销售人员生成旅行计划吗？能使旅行推销员的总行程最小化的最佳解决方案是什么？

以下是我们可用于 TSP 的五个加拿大城市之间的距离：

|  | **渥太华** | **蒙特利尔** | **金斯敦** | **多伦多** | **萨德伯里** |
| **渥太华** | - | 199 | 196 | 450 | 484 |
| **蒙特利尔** | 199 | - | 287 | 542 | 680 |
| **金斯敦** | 196 | 287 | - | 263 | 634 |
| **多伦多** | 450 | 542 | 263 | - | 400 |
| **萨德伯里** | 484 | 680 | 634 | 400 | - |

请注意，目标是获得在初始城市开始和结束的旅行。例如，一次典型的旅行可以是渥太华-萨德伯里-蒙特利尔-金斯敦-多伦多-渥太华，费用为*484+680+287+263+450=2164*。这是推销员必须走最短距离的旅行吗？能使旅行推销员的总行程最小化的最佳解决方案是什么？我将把这件事留给你去思考和计算。

# 使用暴力策略

首先想到的解决 TSP 的方法是使用蛮力找出最短路径，在该路径中，销售人员只访问每个城市一次，然后返回初始城市。因此，暴力策略的工作原理如下：

1.  评估所有可能的旅行。
2.  选择距离最短的一个。

问题是*n*个城市有*（n-1）！*可能的旅行。这意味着五个城市将生产*4！=24*行程，我们将选择与最低距离相对应的行程。很明显，这种方法只会起作用，因为我们没有太多的城市。随着城市数量的增加，暴力策略变得不稳定，因为使用这种方法会产生大量的排列。

让我们看看如何在 Python 中实现暴力策略。

首先，请注意一个 tour，{1,2,3}表示从城市 1 到城市 2 和城市 3 的城市旅行。巡更中的总距离是巡更中覆盖的总距离。我们假设城市之间的距离是它们之间的最短距离（即欧几里德距离）。

让我们首先定义三个实用函数：

*   `distance_points`：计算两点之间的绝对距离
*   `distance_tour`：计算销售人员在给定旅行中必须走的总距离
*   `generate_cities`：随机生成一组*n*个城市，位于宽度`500`和高度`300`的矩形中

让我们看看下面的代码：

```py
import random
from itertools import permutations
alltours = permutations 

def distance_tour(aTour):
    return sum(distance_points(aTour[i - 1], aTour[i]) 
               for i in range(len(aTour)))

aCity = complex

def distance_points(first, second): return abs(first - second)

def generate_cities (number_of_cities):
    seed=111;width=500;height=300
    random.seed((number_of_cities, seed))
    return frozenset(aCity(random.randint(1, width), random.randint(1, height))
                     for c in range(number_of_cities))
```

在前面的代码中，我们通过`itertools`包的`permutations`函数实现了`alltours`。我们还用复数表示了距离。这意味着：

*   计算两个城市之间的距离*a*和*b*与`distance (a,b)`一样简单，
*   我们只需拨打`generate_cities(n)`就可以创建*n*个城市。

现在让我们定义一个函数，`brute_force`，它生成所有可能的城市旅游。一旦生成了所有可能的行程，它将选择距离最短的行程：

```py
def brute_force(cities):
    "Generate all possible tours of the cities and choose the shortest 
     tour."
    return shortest_tour(alltours(cities))

def shortest_tour(tours): return min(tours, key=distance_tour)
```

现在，让我们定义可以帮助我们绘制 cites 的实用函数。我们将定义以下功能：

*   `visualize_tour`：绘制特定旅游中的所有城市和链接。它还突出了旅游开始的城市。
*   `visualize_segment`：用于`visualize_tour`绘制某段中的引用和链接。

请看以下代码：

```py
%matplotlib inline
import matplotlib.pyplot as plt
def visualize_tour(tour, style='bo-'): 
    if len(tour) > 1000: plt.figure(figsize=(15, 10))
    start = tour[0:1]
    visualize_segment(tour + start, style)
    visualize_segment(start, 'rD') 

def visualize_segment (segment, style='bo-'):
    plt.plot([X(c) for c in segment], [Y(c) for c in segment], style, clip_on=False)
    plt.axis('scaled')
    plt.axis('off')

def X(city): "X axis"; return city.real
def Y(city): "Y axis"; return city.imag
```

让我们实现一个函数`tsp()`，它执行以下操作：

1.  根据算法和请求的城市数生成旅游
2.  计算算法运行所需的时间
3.  生成一个绘图

一旦`tsp()`被定义，我们就可以使用它来创建一个旅行：

![](assets/772acb6f-707d-4628-9e83-78a5b830cb2e.png)

注意，我们已经使用它生成了 10 个城市的旅游。当*n**=10*时，生成*（10-1）！=**362880*可能的排列。如果*n*增加，排列数量急剧增加，无法使用蛮力法。

# 使用贪婪算法

如果我们使用贪婪算法来求解 TSP，那么，在每一步中，我们都可以选择一个看起来合理的城市，而不是找到一个能够得到最佳总体路径的城市进行访问。因此，每当我们需要选择一个城市时，我们只需选择最近的城市，而不用费心验证这个选择是否会产生全局最优路径。

贪婪算法的方法很简单：

1.  从任何城市开始。
2.  在每一步中，通过移动到下一个城市，在那里最近的社区以前从未被访问过，继续构建旅游。
3.  重复*步骤 2。*

让我们定义一个名为`greedy_algorithm`的函数来实现此逻辑：

```py
def greedy_algorithm(cities, start=None):
    C = start or first(cities)
    tour = [C]
    unvisited = set(cities - {C})
    while unvisited:
        C = nearest_neighbor(C, unvisited)
        tour.append(C)
        unvisited.remove(C)
    return tour

def first(collection): return next(iter(collection))

def nearest_neighbor(A, cities):
    return min(cities, key=lambda C: distance_points(C, A))
```

现在，让我们用`greedy_algorithm`创建一个 2000 个城市的旅游：

![](assets/dd42feb1-1b10-4448-97c9-115cd8e3528b.png)

请注意，只需 0.514 秒即可生成 2000 个城市的旅游。如果我们使用暴力方法，它会生成*（2000-1）！*置换，几乎是无限的。

请注意，贪婪算法是基于启发式的，没有证据表明该解决方案是最优的。

现在，让我们看看 PageRank 算法的设计。

# 介绍了 PageRank 算法

作为一个实际的例子，让我们看看 PageRank 算法，它最初被 Google 用来对用户查询的搜索结果进行排名。它生成一个数字，量化用户执行的查询上下文中搜索结果的重要性。这是由两位博士设计的。上世纪 90 年代末，斯坦福大学的学生拉里·佩奇和谢尔盖·布林也创立了谷歌。

The PageRank algorithm was named after Larry Page, who created it with Sergey Brin while studying at Stanford University.

让我们首先正式定义 PageRank 最初设计的问题。

# 问题定义

每当用户在 web 上的搜索引擎上输入查询时，通常会产生大量结果。为了使结果对最终用户有用，使用一些标准对网页进行排名是很重要的。显示的结果使用此排名为用户总结结果，并取决于所使用的基础算法定义的标准。

# PageRank 算法的实现

PageRank 算法最重要的部分是找到计算查询结果返回的每个页面的重要性的最佳方法。为了计算一个从`0`到`1`的数字来量化特定页面的重要性，该算法结合了以下两个部分的信息：

*   **特定于用户输入的查询的信息**：该组件在用户输入的查询上下文中估计网页内容的相关性。页面的内容直接取决于页面的作者。
*   **与用户输入的查询不相关的信息**：该组件试图量化每个网页在其链接、视图和邻居上下文中的重要性。这个组件很难计算，因为 web 页面是异构的，并且很难制定可在 web 上应用的标准。

为了在 Python 中实现 PageRank 算法，首先，让我们导入必要的库：

```py
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
%matplotlib inline
```

为了演示，假设我们只分析网络中的五个网页。我们将这组页面称为`myPages`，它们一起位于一个名为`myWeb`的网络中：

```py
myWeb = nx.DiGraph()
myPages = range(1,5)
```

现在，让我们随机连接它们以模拟实际网络：

```py
connections = [(1,3),(2,1),(2,3),(3,1),(3,2),(3,4),(4,5),(5,1),(5,4)]
myWeb.add_nodes_from(myPages)
myWeb.add_edges_from(connections)
```

现在，让我们绘制这个图表：

```py
pos=nx.shell_layout(myWeb)
nx.draw(myWeb, pos, arrows=True, with_labels=True)
plt.show()
```

它创建了我们网络的可视化表示，如下所示：

![](assets/5bff14a4-3a17-4186-bb25-c9a898075152.png)

在 PageRank 算法中，网页的模式包含在一个称为转移矩阵的矩阵中。有些算法会不断更新转换矩阵，以捕获不断变化的 web 状态。转移矩阵的大小为*n x n*，其中*n*为节点数。矩阵中的数字是访问者由于出站链接而下一次访问该链接的概率。

在我们的例子中，前面的图表显示了我们拥有的静态 web。让我们定义一个可用于创建转换矩阵的函数：

![](assets/40bb15c0-107d-4743-92c8-6933a8fdd79b.png)

请注意，此函数将返回*G*，它表示图形的转移矩阵。

让我们为图形生成转换矩阵：

![](assets/94bc5bfb-e6af-4856-821e-1cb2c73c0642.png)

注意，对于我们的图，转移矩阵是*5x5*。每列对应于图中的每个节点。例如，第 2 列是关于第二个节点的。访问者从节点 2 导航到节点 1 或节点 3 的概率为 0.5。注意，转移矩阵的对角线是`0`，正如在我们的图中一样，没有从节点到自身的出站链接。在实际网络中，这是可能的。

请注意，转移矩阵是稀疏矩阵。随着节点数量的增加，其大部分值将为`0`。

# 理解线性规划

线性规划背后的基本算法是由 George Dantzig 在 20 世纪 40 年代初在加州大学伯克利分校开发的。Dantzig 在为美国空军工作时，利用这一概念对部队的后勤供应和能力规划进行了试验。第二次世界大战结束时，Dantzig 开始为五角大楼工作，并将他的算法成熟为一种他命名为线性规划的技术。它被用于军事作战计划。

今天，它被用于解决与基于特定约束最小化或最大化变量相关的重要现实问题。这些问题的一些例子如下：

*   基于资源最大限度地缩短在机械修理厂修理汽车的时间
*   在分布式计算环境中分配可用的分布式资源以最小化响应时间
*   基于公司内部资源的最优分配，实现公司利润最大化

# 线性规划问题的构造

使用线性规划的条件如下：

*   我们应该能够通过一组方程式来描述这个问题。
*   方程中使用的变量必须是线性的。

# 定义目标函数

请注意，前面三个示例中的每个示例的目标都是最小化或最大化变量。该目标在数学上表示为其他变量的线性函数，称为目标函数。线性规划问题的目标是最小化或最大化目标函数，同时保持在指定的约束范围内。

# 指定约束

当试图最小化或最大化某件事情时，现实世界中的问题中有一些约束需要得到尊重。例如，当试图最小化修理汽车所需的时间时，我们还需要考虑到可用的机械数量有限。通过线性方程指定每个约束是制定线性规划问题的一个重要部分。

# 实际应用–线性规划容量规划

让我们看一个实际的用例，其中线性规划可以用来解决现实世界中的问题。让我们假设我们想要最大化一家生产两种不同类型机器人的先进工厂的利润：

*   **高级车型（A）**：提供全功能。制造每一台先进型号的产品可获得 4200 美元的利润。
*   **基本型号（B）**：仅提供基本功能。制造基本型号的每一个单元可产生 2800 美元的利润。

制造机器人需要三种不同类型的人。制造每种类型的机器人所需的确切天数如下：

| **机器人类型** | **技术员** | **人工智能专家** | **工程师** |
| 机器人 A：先进型号 | 三天 | 4 天 | 4 天 |
| 机器人 B：基本模型 | 2 天 | 三天 | 三天 |

工厂以 30 天为周期运行。一个人工智能专家可以在一个周期内工作 30 天。这两名工程师将在 30 天内分别休假 8 天。因此，工程师在一个周期内只能工作 22 天。在 30 天的周期内，只有一名技术人员可以工作 20 天。

下表显示了我们在工厂的人数：

|  | **技术员** | **人工智能专家** | **工程师** |
| 人数 | 1. | 1. | 2. |
| 一个周期内的总天数 | 1 x 20=20 天 | 1 x 30=30 天 | 2 x 22=44 天 |

这可以建模如下：

*   最大利润=4200A+2800B
*   这取决于以下条件：
    *   A≥0:生产的先进机器人数量可以是`0`或更多。
    *   B≥0：生产的基本机器人数量可以是`0`或更多。
    *   3A+2B≤ 20：这些是技师可用性的限制。
    *   4A+3B≤ 30：这些是 AI 专家可用性的限制。
    *   4A+3B≤ 44：这些是工程师可用性的限制。

首先，我们导入名为`pulp`的 Python 包，用于实现；线性规划：

```py
import pulp
```

然后，我们调用这个包中的`LpProblem`函数来实例化问题类。我们将实例命名为`Profit maximising problem`：

```py
# Instantiate our problem class
model = pulp.LpProblem("Profit maximising problem", pulp.LpMaximize)
```

然后，我们定义了两个线性变量，`A`和`B`。变量`A`表示生产的高级机器人数量，变量`B`表示生产的基本机器人数量：

```py
A = pulp.LpVariable('A', lowBound=0, cat='Integer') 
B = pulp.LpVariable('B', lowBound=0, cat='Integer')
```

我们将目标函数和约束定义如下：

```py
# Objective function
model += 5000 * A + 2500 * B, "Profit"

# Constraints
model += 3 * A + 2 * B <= 20 
model += 4 * A + 3 * B <= 30
model += 4 * A + 3 * B <= 44
```

我们使用`solve`函数生成一个解决方案：

```py
# Solve our problem
model.solve()
pulp.LpStatus[model.status]
```

然后打印`A`和`B`的值以及目标函数的值：

![](assets/9ef602d5-4191-4349-91f0-962727d49841.png)

Linear programming is extensively used in the manufacturing industry to find the optimal number of products that should be used to optimize the use of available resources.

这一章到此结束！让我们总结一下我们学到的东西。

# 总结

在本章中，我们介绍了设计算法的各种方法。我们研究了选择正确的算法设计所涉及的权衡问题。我们研究了制定现实世界问题的最佳实践。我们还研究了如何解决现实世界中的优化问题。从本章中吸取的经验教训可用于实施精心设计的算法。

在下一章中，我们将重点介绍基于图的算法。我们将从研究表示图形的不同方式开始。然后，我们将研究在各种数据点周围建立邻域以进行特定调查的技术。最后，我们将研究从图中搜索信息的最佳方法。*