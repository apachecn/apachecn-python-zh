# 散列

散列有两个主要目的：第一个目的是在文件上放置指纹，以便您可以判断文件是否已被更改；第二个目的是隐藏密码，以便您仍然可以识别正确的密码并启用登录，但窃取散列的人无法轻松从中恢复密码。

在本章中，我们将介绍以下主题：

*   MD5 和 SHA 哈希
*   Windows 密码哈希
*   Linux 密码哈希
*   挑战 1–破解 Windows 哈希
*   挑战 2–破解多轮哈希
*   挑战 3–破解 Linux 哈希

# MD5 和 SHA 哈希

在解释了什么是散列函数之后，我们将处理 MD5，然后是 SHA 系列：SHA-1、SHA-2 和 SHA-3。我们还将获得一些关于破解哈希的信息。

# 什么是散列？

如前所述，使用哈希的一个要点是在文件上放置指纹。您可以获取文件中的所有字节，并使用哈希算法将它们组合在一起，这将创建一个固定链接哈希值。如果更改文件的任何部分并重新计算哈希，则会得到完全不同的值。所以，这个想法是，如果你有两个应该相同的文件，你可以计算每个文件的散列，如果两个文件的散列匹配，那么这些文件是相同的。

一个非常常见的散列是 MD5；它已经存在了几十年了。它有 128 位长，对于散列函数来说相当短，并且对于大多数用途来说都足够可靠。人们用它在下载、恶意软件样本和各种东西上留下指纹，有时还用来隐藏密码。它不是一个完美的散列函数：已知有一些冲突，有一些算法可以以牺牲一些计算机时间为代价创建冲突，这些冲突是散列到相同值的成对文件。因此，如果您确实找到两个 MD5 匹配的文件，您无法完全确定它们是相同的文件，但它们通常是相同的。

用 Python 计算它们非常容易。您只需导入哈希库，然后继续计算。调用哈希库来创建新对象。第一个参数是使用的算法，即 MD5。第二个参数是要散列的数据的内容。

在这里，我们将以`HELLO`为例，然后您需要在末尾使用十六进制摘要，否则它只会在数据结构中打印一个地址，而不会显示实际值。我们将使用`HELLO`的散列、MD5 和十六进制，长度为 128 位。因此，这是 128 个 16 进制字符，或者 32 个，如果你在`HELLO`中添加另一个字符，比如感叹号，散列会完全改变；一个值的散列和下一个值的散列之间没有相似之处。

**安全散列算法**（**SHA**）的设计是为了改进 MD5，而 SHA-1 直到大约一年前才出现冲突，当时谷歌公司的一些研究人员发现了如何在 SHA-1 中进行冲突，因此谨慎的人们正转向 SHA-2。**国家标准研究所**批准了另一种算法，称为**SHA-3**，几乎没有人在使用这种算法，因为据任何人所料，SHA-2 在通信系统中会保持很长时间的安全。但是，如果 SHA-2 出现问题，我们可以使用 SHA-3。SHA-2 和 SHA-3 都有不同的长度，但最常见的长度是 256 和 512 位。

您可以在 Python 中轻松地计算 SHA-1 和 SHA-2 哈希，但 SHA-3 并不常用，它还不是此哈希库的一部分。因此，如果在算法中使用 SHA-1，就会得到一个 SHA-1 散列。它看起来像 MD5 散列，但它更长。还有 SHA-256 和 SHA-512，它们都是 SHA-2 散列。您可以看到，虽然它们更安全，但它们要长得多，也不太方便：

![](../images/00043.jpeg)

那么，让我们来看一看。

打开终端，执行`python`命令启动 Python 终端：

![](../images/00044.jpeg)

然后可以运行以下命令：

![](../images/00045.jpeg)

您必须导入`hashlib`。然后，您可以添加`hashlib.new`。第一个参数是算法，在本例中为`md5`。下一个参数是要散列的数据，即`HELLO`，然后添加`hexdigest`以查看十六进制值。因此，这里有一个`HELLO`的散列，如果我们在末尾加上另一个字符，使其读作`HELLOa`，那么我们会得到一个完全不同的答案：

![](../images/00046.jpeg)

如果我们想使用不同的算法，我们只需输入 SHA-1：

![](../images/00047.jpeg)

现在我们得到一个长的散列，如果我们将`sha256`添加为字符，我们得到一个更长的散列：

![](../images/00048.jpeg)

这些散列对于几乎任何目的都是足够的。

如果你有某个东西的散列值，并且你想计算它来自的数据，原则上，没有唯一的解决方案。然而，在实践中，对于像密码这样的短对象，有一个。因此，如果有人使用`MD5`函数来隐藏密码，这是由一些旧的 web 应用程序完成的，那么您可以通过猜测密码来撤销密码，直到找到匹配项。没有数学方法可以撤销散列函数，所以您只需要创建一个库。在`HELLO`的`MD5`散列的例子中，如果你只是做了一系列猜测，你就会得到正确的答案。这就是散列破解的工作原理；这不是一个复杂的想法，只是有点不方便。

我们可以使用`HELLO`的 MD5 散列并继续猜测：

![](../images/00049.jpeg)

如果我们在猜测单词，我们可能需要猜测数百万个单词才能得出显示的值，但是如果我们能够猜测正确的值，那么当散列匹配时，我们就会知道它是正确的。唯一决定这一点难度的是每秒可以计算多少哈希值，MD5 和 SHA 系列设计的计算速度非常快，因此实际上每秒可以使用它们尝试数百万个密码。在下一节中，我们将讨论 Windows 密码哈希。

# Windows 密码哈希

在本节中，我们将了解如何使用 Cain 获取哈希，然后了解 MD4 和 Unicode 是如何工作的。然后，我们将讨论如何使用 Google 破解哈希，以及如何使用单词列表破解哈希。

# 与 Cain 一起得到哈希值

Cain 是一个免费的黑客工具，可以从运行的操作系统中获取 Windows 哈希。为了测试它，我们将在最新版本的 Windows 操作系统 Windows Server 上创建三个帐户。可以在命令提示下使用用户命令来执行此操作。您可以添加名为`John`且密码为`P@sw0rd`的用户、名为`Paul`且密码为`P@sw0rd999`的用户和名为`Ringo`且密码为`P@sw0rd999`的用户：

![](../images/00050.jpeg)

如果运行 Cain，它可以获取哈希值。以下屏幕截图显示了这三个用户及其哈希：

![](../images/00051.jpeg)

LM 哈希部分是一个过时的系统，任何版本的 Windows 都不再使用它，因此它只包含一个没有任何信息的伪值。Windows 在登录时使用的实际哈希称为 NT 哈希。请注意，如果两个用户拥有相同的密码，那么他们拥有完全相同的散列：一个`464`值。这是这个系统的弱点之一。不幸的是，这是一个非常脆弱和陈旧的密码系统。

# MD4 和 Unicode

这是微软使用的算法。它接受密码并以 Unicode 而不是 ASCII 编码，然后通过 MD4（这是一种非常古老的算法，甚至比 MD5 还要古老）运行它时，它会生成 NT 哈希值：

![](../images/00052.jpeg)

之所以使用 Unicode，是因为 Microsoft 是一个国际操作系统，它允许您使用中文和日文等语言的密码，这些语言的编码不是每个字符 8 位，而是每个字符 16 位。

# 用谷歌破解散列

由于密码散列没有变化，任何两个使用相同密码的用户都将拥有相同的散列，因此过去 24 年来破解单词列表的所有黑客都将其结果发布在互联网上，从而导致一种情况，即你可以通过谷歌搜索常用密码散列：

![](../images/00053.jpeg)

如果你只是把一个散列放入谷歌，你经常会发现有人已经为你破解了它并把它放到了互联网上。例如，这一个`P@sw0rd`有一个已知的结果，所以你可以破解它。这种简单的方法适用于大量密码，但这种技术不适用于密码，我们用于用户`Ringo`，即`P@sw0rd999`。

# 用单词表破解哈希

因此，如果密码无法破解，您需要自己计算：

![](../images/00054.jpeg)

你只需要使用相同的程序。做一系列的猜测，把它们搞乱，然后寻找你的答案。如果你的猜测列表最终达到了正确的值，你当然会在这里找到它。因此，您可以看到带有`5c2c...`的密码`P@sw0rd999`。

它非常简单，所以让我们在 Python 中尝试一下。

在终端窗口中，我们将输入`python`命令。接下来我们将导入`hashlib`库：

![](../images/00055.jpeg)

因此，您可以看到执行编码的行。我们输入密码，编码为`utf-16le`，即 Unicode；然后，我们用 MD4 散列它，并将其表示为`hexdigest`。

这是`P@sw0rd`的号码。现在，如果我们试图找到`Ringo`用户，我们需要一个包含两个散列的列表来尝试，这需要有一些最终达到正确值的值：

![](../images/00056.jpeg)

如果我们只是使用`997`、`998`和`999`顺序计数，我们将得到我们要寻找的`5c2c...`值。

# Linux 密码哈希

在本节中，我们将首先讨论如何从操作系统中获取哈希，然后研究使 Linux 哈希更强大的盐析和拉伸过程。然后，我们将讨论现代版本的 Linux 使用的特定哈希算法，最后看看如何使用单词列表和 Python 破解哈希。

在这里，我们创建了三个用户来测试软件，测试方式与我们之前在 Windows 上所做的大致相同。`John`与`Paul`密码相同，`Ringo`密码不同：

![](../images/00057.jpeg)

您可以从`/etc/shadow`文件中获取哈希值，我们将从中打印出最后三条记录。所以，你会看到`John`、`Paul`和`Ringo`，在每个用户名之后都会出现`$6`，这表示它是第 6 类密码，这是最现代、最安全的形式。然后是一个长的、随机的字符串，一直到下一个美元符号，然后是一个更长的随机字符串，这就是密码散列本身。

您可以看到的第一件事是密码散列，它比 Windows 密码散列长得多，也复杂得多。接下来要观察的是，尽管`John`和`Paul`有相同的密码，但它们的哈希值完全不同，因为在对它们进行哈希运算之前，它会向每个密码添加一个随机的`salt`，以掩盖这些密码相同的事实，从而使密码更加强大。salt 是在散列之前添加随机字符的过程；这里也使用拉伸。它不只是使用一轮 MD4，而是使用 5000 轮 SHA-512，这使得计算哈希需要更多的 CPU 时间。这一点是为了减缓攻击者试图制作密码哈希字典的速度。

您可以在`/etc/login.defs`文件中找到该方法的详细信息，该文件显示了使用 crypt 方法`SHA51`2 和`5000`的 Linux 的现代版本：

![](../images/00058.jpeg)

因此，该过程要求您将`salt`与密码组合。您执行的算法包括 5000 轮 SHA-512 哈希。它实际上有 20 多个步骤，包括将两个哈希值放在一起，并将比特混合在一起，但这比反复重复相同的哈希算法要复杂一些。

我们将使用`passlive`图书馆。在 Python 中使用它之前，必须使用`pip install passlib`命令安装它。一旦得到它，就可以导入`sha512_crypt`模块。以下是您如何使用它：

![](../images/00059.jpeg)

让我们启动 Python 终端。然后我们可以导入前面所示的`passlib`库，因为我们已经将它放在`pip install`中了。

现在，我们可以计算第一个，它将使用阴影文件中的`salt`值并对其进行散列，如前一个屏幕截图所示。

如您所见，我们得到了正确的结果（从`r7k`开始）。而且，如果我们进行字典攻击，我们将进行一系列密码猜测，如图所示：

![](../images/00060.jpeg)

这只是一个尝试的问题，直到你得到一个匹配的。

# 挑战 1–破解 Windows 哈希

在回顾了 Windows 哈希和一个 1 位数哈希示例之后，我们将给您两个挑战，一个是 2 位数密码，另一个是 7 位数密码。以下是 Windows 哈希在 Python 中的外观：

![](../images/00061.jpeg)

该算法使用`hashlib`对密码的散列进行 MD4，但在此之前，用 Unicode 编码，即`utf-16le`，然后计算结果的`hexdigest`得到长数字，数字以`464`开头，在这种情况下，这是一个 Windows 密码散列。

因此，您可以编写一个程序，尝试该字符串中的所有字符（由 10 位数字组成），然后计算每个字符的哈希值。您将得到一个包含 10 个值的简单字典：

![](../images/00062.jpeg)

您可以使用 1 位密码破解此 1 位哈希，如下所示：

![](../images/00063.jpeg)

所以，这里有一个挑战。密码是介于 00 和 99 之间的 2 位数字，这是哈希：

![](../images/00064.jpeg)

所以，你必须做一个循环，尝试 100 个可能的值。

下一个是 7 位密码，这是哈希：

![](../images/00065.jpeg)

因此，您必须尝试 1000 万个值。这只需要几秒钟，这就是为什么 Windows 密码哈希非常弱，每秒可以尝试数百万次。

# 挑战 2–破解多轮哈希

在回顾了 MD5 和 SHA 在 Python 中的工作方式之后，我们将了解多轮散列是什么，然后您将面临两个需要解决的挑战。

MD5 和 SHA 都很容易计算：

![](../images/00066.jpeg)

从`hashlib`库中，您只需使用`hashlib.new`方法，将算法名称放在第一个参数中，密码放在第二个参数中，然后将十六进制摘要添加到其中，以十六进制形式查看实际结果，而不仅仅是对象的地址。要进行多次循环，只需重复该过程。

您需要将密码放入`h`中，然后使用当前的`h`，计算下一个`h`并反复重复。这里有一个小脚本，用于打印多轮 MD5 哈希的第一轮`10`：

![](../images/00067.jpeg)

这种技术被称为**拉伸**，它被更强大的密码散列例程使用，比如我们在前面章节中看到的 Linux 密码散列。

这是您的第一个挑战：使用 MD5 对 3 位密码进行 100 次哈希运算。从这个散列中找到它：

![](../images/00068.jpeg)

你还有一个挑战。在本例中，SHA-1 的发数未知，但不超过 5000 发。因此，您只需尝试所有值，然后在此哈希中找到结果的 3 位密码。

# 挑战 3–破解 Linux 哈希

在回顾 Linux 哈希之后，我们将向您展示您的挑战。

Linux 散列是经过腌制和拉伸的，有各种版本。我们将介绍当前版本，即版本 6，即最安全的形式：

![](../images/00069.jpeg)

散列是一个以美元符号开头的长字符串；`6`表示版本，然后有一个美元符号后跟`salt`，另一个美元符号后跟哈希。要在 Python 中计算它们，需要导入一个特殊的 SHA-512`crypt`库，正如前面所示的格式。

这是您的第三个挑战：此格式的 3 位密码。`salt`值是`penguins`，而`hash`是从`P`实例开始的长混乱。

# 总结

在本章中，我们介绍了 MD5 和 SHA-1 哈希算法、Windows 密码哈希算法和 Linux 密码哈希算法。在挑战中，您破解了一个 Windows 密码哈希以恢复明文密码，并破解了另一个密码哈希，使用了未知数量的 MD5 和 SHA-1 轮。最后，您破解了 Linux 密码哈希以恢复明文密码。

在[第三章](3.html#1DOR00-6963dc2081804897894c8854b7cc74fd)*强加密*中，我们将介绍两种主要的强加密方法，即 AES 和 RSA。